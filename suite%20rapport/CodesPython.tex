\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[frenchb]{babel}
\usepackage{xcolor}
\usepackage{listings}
\lstset{
literate=
{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
{À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
{œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
{ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
{ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
{€}{{\EUR}}1 {£}{{\pounds}}1
}
\lstdefinestyle{stylepython}{
        language=Python,
        basicstyle=\ttfamily,
    commentstyle=\color{green},
    keywordstyle=\color{blue},
    stringstyle=\color{olive},
    numberstyle=\tiny,
        numbers=left,
        stepnumber=1,
        numbersep=5pt
}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true
}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{versions}
\usepackage{setspace}
\usepackage{pdfpages}
\usepackage{ulem}
\definecolor{nameColor}{HTML}{26619C}
\usepackage{csquotes}% package pour gérer les guillemets (requis pour biblatex)
\usepackage{hyperref}
\usepackage[left=1.5cm,right=3cm,top=1.5cm,bottom=2cm]{geometry}

\begin{document}\
\begin{figure}\
	\flushright
		\includegraphics[scale=0.2]{ups.png}
\end{figure}

\renewcommand\fbox{\fcolorbox{nameColor}{white}}
\fboxrule 2pt \fbox{
\parbox{15cm}{

\setlength{\parskip}{.10cm}
\vspace{2cm}
\begin{center}
	\begin {LARGE} 
		Modélisation des tumeurs cérébrales\\
		\\
		\\
		\textbf{Partie: Codes Python} 
		\\
		\bigskip
UE Stage \\
	\end {LARGE}
\vspace{2cm}
 
 	Laura FUENTES VICENTE \\
	- Année 2021 - \\
\vspace{2cm}	
    \includegraphics[scale=0.2]{13541540425_63372041e1_z.jpg}
    \\
\vspace{2cm}
	IJCLAB – CNRS\\
	Adresse \\
	Maître de Stage : Mathilde BADOUAL \\ 
	Enseignant Référent : Sabir JACQUIR \\
	Directeur du laboratoire : Achille STOCCHI \\
	\vspace{2cm}
\end{center}}
}
\newpage
\\

\\
\doublespacing
\tableofcontents
\\
Pour retourner vers la partie principale du rapport de stage, faire click \href{run:./suite-rapport.pdf}{\textbf{ici}} 
\url{run:/path/to/my/file.ext}

\newpage
\\
\singlespacing
\section{Modélisation sans Radiothérapie - Méthode Matrice}
\\
\subsection{La diffusion, la prolifération et la comparaison à la solution exacte:}

\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#définition des paramètres du temps
Tempstot = 40 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance en effet 
##de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))


#parameèer L= taille physique boite(mm)/ 
L= 45 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2 #en mm**2
N1 = int(L/dx) #taille de la representation de l'espace 
print("N1= ", N1)
X = np.arange(0, L, dx)
print("X= ", X)

D = 1 #coeff de diffusion mm^2/ans
alpha = (D*(Delta_t)/dx2) #defini par rapport à l'intervalle de temps, dx et D
k=1 #coeff de prolifération (en ans^-1)
print("alpha=", alpha) 

#création des figures vides  
fig, ax1 = plt.subplots(ncols=1)
fig.subplots_adjust(wspace=0.75)
fig2, ax2 = plt.subplots(ncols=1)
fig2.subplots_adjust(wspace=0.75)
fig3, ax3 = plt.subplots(ncols=1)
fig3.subplots_adjust(wspace=0.75)

#matrice M1D pour les prochains calculs
def MatriceM1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    
    for i in range (0, N1): 
        for j in range (0, N1): 
            if (i == j) : 
                MD1[i,j]= 1. + 2*alpha
            elif (i+1 == j or i-1 == j) : 
                MD1[i,j]= -alpha
    MD1[0,1]= 0. -2*alpha
    MiD1= np.linalg.inv(MD1)           
    return MD1 , MiD1           

MD1, MiD1 = MatriceM1(N1, alpha)
print("MD1= ", MD1)

#Matrice avec valeurs initiales de U0 à partir 
#des conditions initiales données par la gaussienne
def MatriceU0(N1, X, t0): 
    U0=np.zeros(N1)
    for i in range (0, N1-1):
       U0[i] = np.exp(-(X[i]**2)/(4*D*t0))
    return U0

U0 = MatriceU0(N1, X, 0.1)

#définition de la solution exacte  de la diffusion pour comparer 

def sol_exacteD(X, t0, t):
    sol_exacteD=np.zeros(N1)
    for i in range(0, N1-1):
        sol_exacteD[i] = 
        ((t0/(t-t0))**(1/2))*(np.exp( -(X[i]**2) / (4*D*(t+t0))))
    return sol_exacteD
sol_exacteD = sol_exacteD(X, 0.1, Tempstot)

#création d'un vecteur vide que l'on remplira par la suite 
Tpreuve = []

def ResD( Tpreuve):
    UT=np.zeros(N1)
    Tpreuve.extend([U0])
    UT=U0
    U=np.zeros(N1)
    for i in range(0, nb_iterations-1):
        U= np.dot(MiD1, UT)
        UT = U
        Tpreuve.extend([U])
    return Tpreuve
Tpreuve = ResD(Tpreuve)
print(np.shape(Tpreuve))


#définition de la solution exacte de la diffusion+prolif pour comparer 
def sol_exacteT(X, t0, t):
    sol_exacteT=np.zeros(N1)
    for i in range(0, N1-1):
        sol_exacteT[i] = ((t0/(t+t0))**(1/2)) * (np.exp( -(X[i]**2) / (4*D*(t+t0)))) * (np.exp(k*t) )
    return sol_exacteT

sol_exacteDP= sol_exacteT(X, 0.1,  Tempstot)

def U6(N1, t0): 
    U6=np.zeros(N1)
    for i in range (0, N1-1):
        U6[i] =  np.exp(-(X[i]**2 + 1.5)/(4*D*t0))
    return U6

U6 = U6(N1, 0.1)
#Calcul prolifération une itération)
def Prolif(U6): 
    UP= np.zeros(N1)
    for i in range(0, N1-1):
        UP[i] = U6[i] + k*Delta_t*U6[i]*(1- (U6[i]))
    U6=UP
    return UP
    
UN=[]
#on repète n fois la fonction de la prolifération 
def nfois(nb_iterations, U6): 
    UN.extend([U6])
    for i in range(0, nb_iterations-1):
        UY = Prolif(U6)
        U6=UY
        UN.extend([UY])
    return UN
UN = nfois(nb_iterations, U6) 

#définition des localisation dans les figures
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique
ax1.set_title("DIFFUSION")
ax1.set_ylabel("Densité cellulaire")
ax1.set_xlabel("Longueur de la boîte (en mm)")
ax1.set_xlim([0,10])
ax1.text(1.1, -0.3, "D=1.0 mm^2/an",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax1.transAxes)
ax1.plot(X, Tpreuve[0], label=" Sol_approch diff t=0*dt")
ax1.plot(X, Tpreuve[5], label=" Sol_approch diff t=5*dt")
ax1.plot(X, Tpreuve[20], label=" Sol_approch diff t=2*dt")
ax1.plot(X, Tpreuve[200], label=" Sol_approch diff t=20*dt")
ax1.plot(X, Tpreuve[500], label=" Sol_approch diff t=50*dt")
ax1.plot(X, Tpreuve[1000], label=" Sol_approch diff t=100*dt")
ax1.plot(X, Tpreuve[2500], label=" Sol_approch diff t=2500*dt")
ax1.plot(X, Tpreuve[nb_iterations-1], label=" Sol_ex diff t=Tempstot")
ax1.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

ax2.set_title("PROLIFÉRATION")
ax2.set_ylabel("Densité cellulaire")
ax2.set_xlabel("Longueur de la boîte (en mm)")
ax2.set_xlim([0,10])
ax2.text(1.1, -0.3, "K=1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax2.transAxes)
ax2.plot(X, UN[0], label=" Sol_ex prolif t=8*dt")
ax2.plot(X, UN[10], label=" Sol_ex prolif t=100*dt")
ax2.plot(X, UN[200], label=" Sol_ex prolif t=200*dt")
ax2.plot(X, UN[500], label=" Sol_ex prolif t=500*dt")
ax2.plot(X, UN[1000], label=" Sol_ex prolif t=1000*dt")
ax2.plot(X, UN[2500], label=" Sol_ex prolif t=2500*dt")
ax2.plot(X, UN[3500], label=" Sol_ex prolif t=3500*dt")
ax2.plot(X, UN[nb_iterations-1], label=" Sol_ex prolif t=nb_iterations*dt")
ax2.legend(bbox_to_anchor=(-0.7, -0.7, -0.7, -0.7), loc='lower left')

ax3.set_title("COMPARAISON SOLUTION APPROCHÉE SOLUTION EXACTE")
ax3.set_ylabel("Densité cellulaire")
ax3.set_xlabel("Longueur de la boîte (en mm)")
ax3.text(1.1, -0.3, "D=1mm^2/an",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax3.transAxes)
ax3.plot(X, sol_exacteD, label=" Sol_ex diff t=tempstot")
ax3.plot(X, Tpreuve[nb_iterations-1], label=" Sol_approch diff t=tempstot")
ax3.legend(bbox_to_anchor=(-0.3, -0.3, -0.3, -0.3), loc='lower left')

#affichage des figures
fig.show()
fig2.show()
fig3.show()
\end{lstlisting}
\newpage
\subsection{Modélisation du processus de diffusion-prolifération - Méthode numerical Recipes: }
\\

\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#paramètres généraux du temps
Tempstot = 30 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance 
##en effet de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

#paramètres généraux de l'espace et autres
#calculer L= taille physique boite(mm)/
L= 70 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la représentation
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion (en mm^2/ans)
k=1 #coeff de prolifération (en ans^-1)
alpha = (D*Delta_t)/dx2 #défini par rapport à l'intervalle de temps, dx et D 
seuil = np.full(N1, 0.07)
seuill = 0.07 #valeur du seuil de detection 
vitfront = 2*np.sqrt(D*k) #vitesse de front 2sqrt(Dk)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k)) #vitesse de front + 10%
vit_front=np.full(nb_iterations-1, 2*np.sqrt(D*k)) #fonction constante avec la vitesse de front
vit_frontdix=np.full(nb_iterations-1, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k))) #fonction contante avec la vitesse de front + 10%

#matrice M1D pour la modélisation 
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#Matrice avec conditions initiales U0 données par la marche
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#calcul de la diffusion une seule itération 
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer la diffusion au rang n+1
def solutions de la diffusion (MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations-1)  

#def d'un tableau vide que l'on remplira avec les valeurs de la diffprolif a tout temps fixé 
TpreuveTemp=[]
#fonction calculant les valeurs de la diffusion puis de la proliferation 

def DiffProlif(TpreuveTemp, U01): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    
    TpreuveTemp.extend([oo])
    for i in range(1, nb_iterations-1):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTemp[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        TpreuveTemp.extend([UP])
    return TpreuveTemp

TpreuveTemp = DiffProlif(TpreuveTemp, U01) #remplissement du vecteur diffprolif

#Calcul du Rayon 
RX= []
RY = []
def rayon(TpreuveTemp, seuill, RX, RY):
    for i in range(0, nb_iterations-1):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTemp[i][j] <= seuill ) and ( TpreuveTemp[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RX.extend([r])
        RY.extend([i*Delta_t])
    return RX, RY
                
RX, RY = rayon(TpreuveTemp, seuill, RX, RY)                
           
#calcul de la pente associée au rayon tumoral
def pente(RY, RX):
    pente = np.zeros(nb_iterations-1)
    for i in range(4, nb_iterations-5):
        pente[i] = (RX[i+4] - RX[i-4]) / (RY[i+4] - RY[i-4])
    return pente 

pente = pente(RY, RX)
max_value = max(pente)
maxi = (np.where(pente == max_value)[0][0])*Delta_t
print("maxi", maxi)

#calcul du tlim
def vitfrontpente(pente, vitfront):
    e=0
    vit10 = []
    g=0
    vit0=[]
    for i in range(0, nb_iterations-1): 
        if ( ( pente[i] <= vitfront ) and ( pente[i-1] >= vitfront ) ): 
            g= (((i-1)+i)/2)*Delta_t
            vit0.extend([g])
            
        elif(( pente[i] <= vitfrontdix ) and ( pente[i-1] >= vitfrontdix )):
            e= (((i-1)+i)/2)*Delta_t
            vit10.extend([e])            
                  
    return vit0, vit10
g, e = vitfrontpente(pente, vitfront)

#création des figures vides 
fig1, ax1 = plt.subplots(ncols=1)
fig1.subplots_adjust(wspace=0.75)
fig2, ax2 = plt.subplots(ncols=1)
fig2.subplots_adjust(wspace=0.75)  
fig3, ax3 = plt.subplots(ncols=1)
fig3.subplots_adjust(wspace=0.75)

#définition des localisations sur les figures
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique
ax1.set_title("DIFFUSION PROLIFERATION SANS RT")
ax1.set_xlabel("Longueur de la boîte (en mm)")
ax1.set_ylabel("Densité cellulaire")
ax1.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax1.transAxes)
ax1.plot(X, TpreuveTemp[0], label="Sol_approch t=0dt")
ax1.plot(X, TpreuveTemp[20], label="Sol_approch t=20dt")
ax1.plot(X, TpreuveTemp[75], label="Sol_approch t=75dt")
ax1.plot(X, TpreuveTemp[250], label="Sol_approch t=250dt")
ax1.plot(X, TpreuveTemp[750], label="Sol_approch t=750dt")
ax1.plot(X, TpreuveTemp[1500], label="Sol_approch t=1500dt")
ax1.plot(X, TpreuveTemp[2500], label="Sol_approch t=2500dt")
ax1.plot(X, TpreuveTemp[nb_iterations-2], label="Sol_approch t=Tempstot")
ax1.plot(X, seuil, label="Seuil=0.07mm")
ax1.legend(bbox_to_anchor=(-0.7, -0.7, -0.7, -0.7), loc='lower left')

ax2.set_title("VARIATION DU RAYON TUMORAL")
ax2.set_xlabel("Temps (en années)")
ax2.set_ylabel("Rayon de la tumeur (en mm)")
ax2.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax2.transAxes)
ax2.set_ylim([0,L])
ax2.plot(RY, RX)
ax2.legend()

ax3.set_title("VARIATION DE LA PENTE ")
ax3.grid(True)
ax3.set_xlabel("Temps (en années)")
ax3.set_ylabel("Coefficient de la pente")
ax3.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax3.transAxes)
ax3.set_xlim([maxi-0.5,Tempstot-1])
ax3.set_ylim([0,10])
ax3.annotate('t0=4.20 années, t10% = 3.75 années', xy=(4.8,2.1), xytext=(6,7.4), arrowprops={'facecolor':'black', 'shrink':0.05} )
ax3.plot(RY, pente, label="Variation de la pente en fonction du temps")
ax3.plot(RY, vit_front, label=r'$ f(x)= 2\sqrt{Dk}$')
ax3.plot(RY, vit_frontdix, label=r' g(x)= $2\sqrt{Dk}$ + 10%')
ax3.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichage figures

fig1.show()
fig2.show()
fig3.show()
\end{lstlisting}
\newpage
\section{Application de la Radiothérapie:}
\\
\subsection{Processus de diffusion proliferation suite à une session de RT}
\\
\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt
\\
Tempstot = 30 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance en effet 
#de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height


#paramètres pour l'espace et autres 
#calculer L= taille physique boîte (mm)/
L= 70  en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la representation de l'espace 
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion
k=1 #coeff de prolifération 
P15=0.9 #proportion des cellules atteintes par la RT
M=2.5 #taux de mort des cellules atteintes par la RT (en ans^-1)
nbt0 = 950 #Moment de l'appli de la RT
alpha = (D*Delta_t)/dx2 #defini par rapport à l'intervalle de temps et dx 
print(alpha)
seuil = np.full(N1, 0.07)
seuill = 0.07
vitfront = 2*np.sqrt(D*k)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k))
vit_front=np.full(nb_iterations, 2*np.sqrt(D*k))
vit_frontdix=np.full(nb_iterations, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k)))


#matrice M1D pour les prochains calculs
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#vecteur avec les conditions initiales données par la marche
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#fonction diffusion une seule itération
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer au rang n+1 les solutions de la diffusion 
def solutions(MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f+1):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations)   

#fonction de la diffusion prolifération avant RT
TpreuveTempRT15=[]
TpreuveTempn15=[]
sommem15 = []

zero = np.zeros(N1)
def DiffProlif(TpreuveTempn, TpreuveTempRT, U01, nbt0, sommem): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    sommem.extend([oo])
    TpreuveTempn.extend([oo])
    TpreuveTempRT.extend([zero])
    for i in range(1, nbt0):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        sommem.extend([UP])
        TpreuveTempn.extend([UP])
        TpreuveTempRT.extend([zero])
    return TpreuveTempn, TpreuveTempRT, sommem

TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlif(TpreuveTempn15, TpreuveTempRT15, U01, nbt0, sommem15) #remplissement du vecteur diffprolif


#fonction calculant les valeurs de la diffusion puis de la prolifération après RT
def DiffProlifRT(TpreuveTempn, M, TpreuveTempRT, nbt0, sommem, p): 
    oo=np.zeros(N1)
    op=np.zeros(N1)
    for i in range(0, N1-1):
        oo[i]= p*TpreuveTempn[nbt0-1][i]
        op[i]= (1-p)*TpreuveTempn[nbt0-1][i]

    Tpreuver = resol(A,B,C, oo)
    Tpreuven = resol(A,B,C, op)
    oo = np.zeros(N1)
    op = np.zeros(N1)
    s = np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=Tpreuver[m] + (M*Delta_t*Tpreuver[m]*(1 - (Tpreuver[m])))
        op[m]= (Tpreuven[m]) + k*Delta_t*Tpreuven[m]*(1 -Tpreuven[m] - Tpreuver[m] )
        s[m]= op[m] + oo[m]
        
    sommem.extend([s])    
    TpreuveTempRT.extend([oo])
    TpreuveTempn.extend([op])
    for i in range(nbt0+1, nb_iterations):
        
        TPRT= np.zeros(N1)
        UPRT=np.zeros(N1)
        TPRT = resol(A,B,C, TpreuveTempRT[i-1])
        s = np.zeros(N1)
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UPRT[j] = TPRT[j] - (M*Delta_t*TPRT[j]*(1-TPRT[j]))
            cd= TPRT[j]
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- TP[j] - cd)
            s[j] = UP[j] +UPRT[j]
            
        sommem.extend([s])
        TpreuveTempRT.extend([UPRT])
        TpreuveTempn.extend([UP])
    return TpreuveTempn, TpreuveTempRT, sommem


TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlifRT(TpreuveTempn15, M, TpreuveTempRT15, nbt0, sommem15, P15) 


#Calcul du rayon 

RXn15= []
RYn15 = []

def rayonn(TpreuveTempn, seuill, RXn, RYn):
    for i in range(0, nb_iterations):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTempn[i][j] <= seuill ) and ( TpreuveTempn[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RXn.extend([r])
        RYn.extend([i*Delta_t])
    return RXn, RYn
                
RXn15, RYn15 = rayonn(sommem15, seuill, RXn15, RYn15)

#Calcul de la valeur minimale du rayon et deltag (intervalle de temps pour atteindre cette dernière)
def minn(RX):
    minim=35
    indice = 0
    deltag=0
    for i in range (nbt0, nb_iterations):
        m = RX[i]
        if (m<minim):
            minim = m
            indice = i *Delta_t
            deltag= (i*Delta_t) - (nbt0*Delta_t)
    return minim, indice, deltag


minimRX15, indicemin15, deltag15 = minn(RXn15) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX15)
print("indice", indicemin15)
print("deltag", deltag15)

#calcul de l'intervalle de temps DeltaG
def momentegal(RX):
    bingo=RX[nbt0]
    DELTAG=0
    for i in range(nbt0, nb_iterations):
        if ( ( RX[i-1] <= bingo ) and ( RX[i] >= bingo ) ):
            DELTAG = (i*Delta_t) - (nbt0*Delta_t) 
    return DELTAG


DELTAG15 = momentegal(RXn15)
print("DELTAG15 = ",DELTAG15)

#création des figures vides
fig2, ax2 = plt.subplots(ncols=1)
fig2.subplots_adjust(wspace=0.75)  

fig4, ax4 = plt.subplots(ncols=1)
fig4.subplots_adjust(wspace=0.75)

#représentation graphique

ax2.set_title(" DIFFUSION PROLIFERATION CELLULES ")
ax2.grid(True)
ax2.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 P=0.9 M=2.5 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax2.transAxes)
ax2.set_xlabel("Longueur de la boîte (en mm)")
ax2.set_ylabel("Densité cellulaire")
ax2.plot(X, sommem15[0], label="sol_approch c t=0dt", color='gray' )
ax2.plot(X, sommem15[20], label="sol_approch c t=20dt", color='gray')
ax2.plot(X, sommem15[50], label="sol_approch c t=50dt", color='gray')
ax2.plot(X, sommem15[250], label="sol_approch c t=250dt", color='gray')
ax2.plot(X, sommem15[400], label="sol_approch ct=400dt ", color='gray')
ax2.plot(X, sommem15[550], label="sol_approch ct=550dt", color='gray')
ax2.plot(X, sommem15[625], label="sol_approch ct=625dt", color='gray')
ax2.plot(X, sommem15[750], label="sol_approch c  t=750dt", color='gray')
ax2.plot(X, sommem15[875], label="sol_approch c  t=875dt", color='gray')
ax2.plot(X, sommem15[950], label="sol_approch c moment irradiation RT t=950dt", color='red')
ax2.plot(X, sommem15[1000], label="sol_approch c  t=1000dt", color='orange')
ax2.plot(X, sommem15[1150], label="sol_approch c  t=1150dt", color='pink')
ax2.plot(X, sommem15[1300], label="sol_approch c t=1300dt ", color='magenta')
ax2.plot(X, sommem15[1500], label="sol_approch c t=1500dt ", color='purple')
ax2.plot(X, sommem15[1750], label="sol_approch c t=1750dt ", color='blue')
ax2.plot(X, sommem15[2000], label="sol_approch c t=2000dt ", color='green')
ax2.plot(X, sommem15[2250], label="sol_approch c t=2250dt ", color='black')
ax2.plot(X, sommem15[2250], label="sol_approch c t=2750dt ", color='black')
ax2.plot(X, sommem15[nb_iterations-1], label="sol_approch c t=Tempstot", color='black')
ax2.legend(bbox_to_anchor=(-0.99, -0.99, -0.99, -0.99), loc='lower left')


ax4.set_title("VARIATION DU RAYON TUMORAL ")
ax4.grid(True)
ax4.set_xlabel("Temps (en années)")
ax4.set_ylabel("Rayon de la tumeur (en mm)")
ax4.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 M=1.1 ans^-1 fixé",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax4.transAxes)
ax4.annotate('Session de radiothérapie', xy=(9,7.1), xytext=(2.5,17.2), arrowprops={'facecolor':'black', 'shrink':0.05} )
ax4.plot(RYn15, RXn15, label="P=0.9")
ax4.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichage figures 
fig2.show()
fig4.show()
\end{lstlisting}
\\
\newpage
\subsection{Étude du paramètre M}
\subsubsection{Variation du Rayon tumoral pour plusieurs valeurs de M }
\\
\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#définition des paramètres temps
Tempstot = 20 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance en effet 
#de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

#paramètres de l'espace et autres 
#calculer L= taille physique boite(mm)/
L= 70 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la représentation de l'espace
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion
k=1 #coeff de prolifération 
M03=1.5 #taux de mort
M06=2.5 #taux de mort
M15=4 #taux de mort
p=0.95 #proportion de cellules atteintes par la RT
 #proportion des cellules atteintes par la RT
nbt0 = 950 #moment de l'appli de la RT
alpha = (D*Delta_t)/dx2 #defini par rapport à l'intervalle de temps, dx et D 
print(alpha)
seuil = np.full(N1, 0.07)
seuill = 0.07 #seuil de détection 
vitfront = 2*np.sqrt(D*k)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k))
vit_front=np.full(nb_iterations, 2*np.sqrt(D*k))
vit_frontdix=np.full(nb_iterations, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k)))


#matrice M1D pour les prochains calculs
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#conditions initiales données par la marche
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#fonction diffusion pour une seule itération 
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer la diffusion au rang n+1
def solutions(MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f+1):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations)   

#création des vecteurs vides que l'on utilisera par la suite:
TpreuveTempRT03=[]
TpreuveTempn03=[]
sommem03 = []

TpreuveTempRT06=[]
TpreuveTempn06=[]
sommem06 = []

TpreuveTempRT15=[]
TpreuveTempn15=[]
sommem15 = []

zero = np.zeros(N1)
#modélisation de la diffusion prolifération avant RT
def DiffProlif(TpreuveTempn, TpreuveTempRT, U01, nbt0, sommem): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    sommem.extend([oo])
    TpreuveTempn.extend([oo])
    TpreuveTempRT.extend([zero])
    for i in range(1, nbt0):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        sommem.extend([UP])
        TpreuveTempn.extend([UP])
        TpreuveTempRT.extend([zero])
    return TpreuveTempn, TpreuveTempRT, sommem
TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlif(TpreuveTempn03, TpreuveTempRT03, U01, nbt0, sommem03) #remplissement du vecteur diffprolif
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlif(TpreuveTempn06, TpreuveTempRT06, U01, nbt0, sommem06) #remplissement du vecteur diffprolif
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlif(TpreuveTempn15, TpreuveTempRT15, U01, nbt0, sommem15) #remplissement du vecteur diffprolif


#fonction calculant les valeurs de la diffusion puis de la prolifération après RT

def DiffProlifRT(TpreuveTempn, M, TpreuveTempRT, nbt0, sommem): 
    oo=np.zeros(N1)
    op=np.zeros(N1)
    for i in range(0, N1-1):
        oo[i]= p*TpreuveTempn[nbt0-1][i]
        op[i]= (1-p)*TpreuveTempn[nbt0-1][i]

    Tpreuver = resol(A,B,C, oo)
    Tpreuven = resol(A,B,C, op)
    oo = np.zeros(N1)
    op = np.zeros(N1)
    s = np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=Tpreuver[m] + (M*Delta_t*Tpreuver[m]*(1 - (Tpreuver[m])))
        op[m]= (Tpreuven[m]) + k*Delta_t*Tpreuven[m]*(1 -Tpreuven[m] - Tpreuver[m] )
        s[m]= op[m] + oo[m]
        
    sommem.extend([s])    
    TpreuveTempRT.extend([oo])
    TpreuveTempn.extend([op])
    for i in range(nbt0+1, nb_iterations):
        
        TPRT= np.zeros(N1)
        UPRT=np.zeros(N1)
        TPRT = resol(A,B,C, TpreuveTempRT[i-1])
        s = np.zeros(N1)
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UPRT[j] = TPRT[j] - (M*Delta_t*TPRT[j]*(1-TPRT[j]))
            cd= TPRT[j]
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- TP[j] - cd)
            s[j] = UP[j] +UPRT[j]
            
        sommem.extend([s])
        TpreuveTempRT.extend([UPRT])
        TpreuveTempn.extend([UP])
    return TpreuveTempn, TpreuveTempRT, sommem

TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlifRT(TpreuveTempn03, M03, TpreuveTempRT03, nbt0, sommem03) 
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlifRT(TpreuveTempn06, M06, TpreuveTempRT06, nbt0, sommem06) 
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlifRT(TpreuveTempn15, M15, TpreuveTempRT15, nbt0, sommem15) 


#Calcul du rayon 
RXn03= []
RYn03 = []

RXn06= []
RYn06 = []

RXn15= []
RYn15 = []

def rayonn(TpreuveTempn, seuill, RXn, RYn):
    for i in range(0, nb_iterations):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTempn[i][j] <= seuill ) and ( TpreuveTempn[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RXn.extend([r])
        RYn.extend([i*Delta_t])
    return RXn, RYn
                
RXn03, RYn03 = rayonn(sommem03, seuill, RXn03, RYn03)  
RXn06, RYn06 = rayonn(sommem06, seuill, RXn06, RYn06)  
RXn15, RYn15 = rayonn(sommem15, seuill, RXn15, RYn15)

#On cherche a trouver le moment où le rayon est minimal suite a la session de RT (deltag) et la valeur minimale du rayon 
def minn(RX):
    minim=35
    indice = 0
    deltag=0
    for i in range (nbt0, nb_iterations):
        m = RX[i]
        if (m<minim):
            minim = m
            indice = i *Delta_t
            deltag= (i*Delta_t) - (nbt0*Delta_t)
    return minim, indice, deltag

minimRX03, indicemin03, deltag03 = minn(RXn03) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX03)
print("indice", indicemin03)
print("deltag", deltag03)


minimRX06, indicemin06, deltag06 = minn(RXn06) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX06)
print("indice", indicemin06)
print("deltag", deltag06)

minimRX15, indicemin15, deltag15 = minn(RXn15) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX15)
print("indice", indicemin15)
print("deltag", deltag15)

#calcul de l'intervalle DeltaG
def momentegal(RX):
    bingo=RX[nbt0]
    DELTAG=0
    for i in range(nbt0, nb_iterations):
        if ( ( RX[i-1] <= bingo ) and ( RX[i] >= bingo ) ):
            DELTAG = (i*Delta_t) - (nbt0*Delta_t) 
    return DELTAG

DELTAG03 = momentegal(RXn03)
print("DELTAG03 = ",DELTAG03)

DELTAG06 = momentegal(RXn06)
print("DELTAG06 = ",DELTAG06)

DELTAG15 = momentegal(RXn15)
print("DELTAG15 = ",DELTAG15)

#création des figures vides 
fig4, ax4 = plt.subplots(ncols=1)
fig4.subplots_adjust(wspace=0.75)

#localisation dans les figures
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique 
ax4.set_title("VARIATION DU RAYON TUMORAL ")
ax4.grid(True)
ax4.set_xlim([0, 18])
ax4.set_ylim([0, 25])
ax4.set_xlabel("Temps (en années)")
ax4.set_ylabel("Rayon de la tumeur (en mm)")
ax4.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 P=0.95 fixés RT=9.5 ans",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax4.transAxes)
ax4.annotate('Session de radiothérapie', xy=(9.5,15.1), xytext=(3.5,20.2), arrowprops={'facecolor':'black', 'shrink':0.05} )
ax4.plot(RYn03, RXn03, label="M=1.1")
ax4.plot(RYn06, RXn06, label="M=2.5")
ax4.plot(RYn15, RXn15, label="M=4")
ax4.legend(bbox_to_anchor=(-0.5, -0.5, -0.5, -0.5), loc='lower left')

#affichage des figures 
fig4.show()
\end{lstlisting}
\\
\newpage
\subsubsection{Étude de la pente associée au rayon tumoral}
\\
\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt


#paramètres du temps
Tempstot = 20 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance 
#en effet de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

#paramètres de l'espace et autres
#calculer L= taille physique boîte(mm)/
L= 70 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la représentation de l'espace
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion
k=1 #coeff de prolifération 
P=0.95 #proportion de cellules atteintes par la RT
M15=1.1 #taux de mort
M25=2.5 #taux de mort
M4=4 #taux de mort
nbt0 = 950 #appli de la RT
alpha = (D*Delta_t)/dx2 #défini par rapport à l'intervalle de temps, dx et D 
print(alpha)
seuil = np.full(N1, 0.07)
seuill = 0.07 #seuil de détection 
vitfront = 2*np.sqrt(D*k)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k))
vit_front=np.full(nb_iterations, 2*np.sqrt(D*k))
vit_frontdix=np.full(nb_iterations, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k)))


#matrice M1D pour les prochains calculs
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#définition d'un vecteur avec les conditions initiales données par la marche
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#résolution diffusion pour une seule itération 
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer la diffusion au rang n+1
def solutions(MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f+1):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations)   

#création des vecteurs vides pour la suite
TpreuveTempRT03=[]
TpreuveTempn03=[]
sommem03 = []

TpreuveTempRT06=[]
TpreuveTempn06=[]
sommem06 = []

TpreuveTempRT15=[]
TpreuveTempn15=[]
sommem15 = []

zero = np.zeros(N1)
#modélisation de la diffusion prolifération avant RT
def DiffProlif(TpreuveTempn, TpreuveTempRT, U01, nbt0, sommem): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    sommem.extend([oo])
    TpreuveTempn.extend([oo])
    TpreuveTempRT.extend([zero])
    for i in range(1, nbt0):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        sommem.extend([UP])
        TpreuveTempn.extend([UP])
        TpreuveTempRT.extend([zero])
    return TpreuveTempn, TpreuveTempRT, sommem
TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlif(TpreuveTempn03, TpreuveTempRT03, U01, nbt0, sommem03) #remplissement du vecteur diffprolif
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlif(TpreuveTempn06, TpreuveTempRT06, U01, nbt0, sommem06) #remplissement du vecteur diffprolif
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlif(TpreuveTempn15, TpreuveTempRT15, U01, nbt0, sommem15) #remplissement du vecteur diffprolif


#fonction calculant les valeurs de la diffusion puis de la prolifération après RT
def DiffProlifRT(TpreuveTempn, M, TpreuveTempRT, nbt0, sommem, p): 
    oo=np.zeros(N1)
    op=np.zeros(N1)
    for i in range(0, N1-1):
        oo[i]= p*TpreuveTempn[nbt0-1][i]
        op[i]= (1-p)*TpreuveTempn[nbt0-1][i]

    Tpreuver = resol(A,B,C, oo)
    Tpreuven = resol(A,B,C, op)
    oo = np.zeros(N1)
    op = np.zeros(N1)
    s = np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=Tpreuver[m] + (M*Delta_t*Tpreuver[m]*(1 - (Tpreuver[m])))
        op[m]= (Tpreuven[m]) + k*Delta_t*Tpreuven[m]*(1 -Tpreuven[m] - Tpreuver[m] )
        s[m]= op[m] + oo[m]
        
    sommem.extend([s])    
    TpreuveTempRT.extend([oo])
    TpreuveTempn.extend([op])
    for i in range(nbt0+1, nb_iterations):
        
        TPRT= np.zeros(N1)
        UPRT=np.zeros(N1)
        TPRT = resol(A,B,C, TpreuveTempRT[i-1])
        s = np.zeros(N1)
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UPRT[j] = TPRT[j] - (M*Delta_t*TPRT[j]*(1-TPRT[j]))
            cd= TPRT[j]
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- TP[j] - cd)
            s[j] = UP[j] +UPRT[j]
            
        sommem.extend([s])
        TpreuveTempRT.extend([UPRT])
        TpreuveTempn.extend([UP])
    return TpreuveTempn, TpreuveTempRT, sommem

TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlifRT(TpreuveTempn03, M15, TpreuveTempRT03, nbt0, sommem03, P) 
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlifRT(TpreuveTempn06, M25, TpreuveTempRT06, nbt0, sommem06, P) 
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlifRT(TpreuveTempn15, M4, TpreuveTempRT15, nbt0, sommem15, P) 


#Calcul du rayon 
RXn03= []
RYn03 = []

RXn06= []
RYn06 = []

RXn15= []
RYn15 = []

def rayonn(TpreuveTempn, seuill, RXn, RYn):
    for i in range(0, nb_iterations):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTempn[i][j] <= seuill ) and ( TpreuveTempn[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RXn.extend([r])
        RYn.extend([i*Delta_t])
    return RXn, RYn
                
RXn03, RYn03 = rayonn(sommem03, seuill, RXn03, RYn03)  
RXn06, RYn06 = rayonn(sommem06, seuill, RXn06, RYn06)  
RXn15, RYn15 = rayonn(sommem15, seuill, RXn15, RYn15)

#calcul de la pente associée à la courbe du rayon
def pente(RY, RX):
    pente = np.zeros(nb_iterations)
    for i in range(4, nb_iterations-5):
        pente[i] = (RX[i+4] - RX[i-4]) / (RY[i+4] - RY[i-4])
    return pente 
pente03 = pente(RYn03, RXn03)
max_value03 = max(pente03)
maxi03 = (np.where(pente03 == max_value03)[0][0])*Delta_t
print("maxi03", maxi03)

pente06 = pente(RYn06, RXn06)
pente06 = pente(RYn06, RXn06)
max_value06 = max(pente06)
maxi06 = (np.where(pente06 == max_value06)[0][0])*Delta_t
print("maxi06", maxi06)

pente15 = pente(RYn15, RXn15)
pente15 = pente(RYn15, RXn15)
max_value15 = max(pente15)
maxi15 = (np.where(pente15 == max_value15)[0][0])*Delta_t
print("maxi15", maxi15)

#création des figures vides 
fig4, ax4 = plt.subplots(ncols=1)
fig4.subplots_adjust(wspace=0.75)

#localisations sur les figures
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique 
ax4.set_title("VARIATION DE LA PENTE")
ax4.grid(True)
ax4.set_xlabel("Temps (en années)")
ax4.set_xlim([0, 19])
ax4.set_ylabel("Coefficient de la pente")
ax4.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 fixées",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax4.transAxes)
ax4.plot(RYn03, pente03, label="Pour M=1.1 pour P=0.95")
ax4.plot(RYn06, pente06, label="Pour M=2.5 pour P=0.95")
ax4.plot(RYn15, pente15, label="Pour M=4 pour P=0.95")
ax4.legend(bbox_to_anchor=(-0.5, -0.5, -0.5, -0.5), loc='lower left')

#affichage des figures 
fig4.show()
\end{lstlisting}
\\ 
\newpage
\subsubsection{Variations des intervalles $\Delta G$ et $\Delta g$ et valeurs du rayon tumoral minimal }
\\
\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#valeurs qu'on a calculé auparavant
RXmp06 = [0.6, 0.7, 0.8, 0.9, 0.99, 1.5, 2.5, 3.0, 4.0]
RXmp09= [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99, 1.5, 2.5, 3.0, 4.0]

#pour P=0.6
VARRAYMINP06 = [6.165, 6.165,6.165, 6.165, 6.165, 6.105, 5.885, 5.775, 5.595]
VARDELTATP06 = [0.0005,0.001,0.05, 0.07, 0.1, 0.48, 0.74,0.79, 0.83]
VARdeltatP06= [0, 0, 0,0, 0, 0.17, 0.31, 0.35, 0.34]

#pour P=0.7
VARRAYMINP07 = [6.165, 6.165,6.165, 6.145, 6.115, 5.935, 5.565, 5.415, 5.155]
VARDELTATP07 = [0.0005,0.03,0.2, 0.42, 0.53, 0.88, 1.07,1.1, 1.12]
VARdeltatP07= [0, 0, 0,0.07, 0.23, 0.42, 0.5, 0.46, 0.45]


#pour P=0.8
VARRAYMINP08 = [6.145, 6.105,6.055, 5.995, 5.935, 5.585, 4.995, 4.755, 4.365]
VARDELTATP08 = [0.43,0.71,0.9, 1.05, 1.14, 1.38, 1.49,1.5, 1.51]
VARdeltatP08= [0.06, 0.31, 0.4,0.47, 0.53, 0.65, 0.65, 0.64, 0.59]

#pour P=0.9
VARRAYMINP09seul = [ 6.155,6.155 ,6.135 , 6.045,5.925, 5.785,5.645, 5.495, 5.365, 4.665, 3.525, 3.025, 2.085]
VARDELTATP09seul = [0.05,0.1,0.75 , 1.32, 1.6,1.77,1.9, 1.97, 2.02, 2.14, 2.17,2.17, 2.16]
VARdeltatP09seul= [0, 0, 0.28,0.73 , 0.86, 1.02, 1.02, 1.11, 1.11, 1.11, 0.97, 0.92, 0.82]

#valeurs calculées auparavant
VARRAYMINP09 = [5.925, 5.785,5.645, 5.495, 5.365, 4.665, 3.525, 3.025, 2.085]
VARDELTATP09 = [1.6,1.77,1.9, 1.97, 2.02, 2.14, 2.17,2.17, 2.16]
VARdeltatP09= [0.86, 1.02, 1.02, 1.11, 1.11, 1.11, 0.97, 0.92, 0.82]

#création des figures vides 
fig1, ax1 = plt.subplots()
figa, axa = plt.subplots()
fig2, ax2 = plt.subplots()
figb, axb = plt.subplots()
fig3, ax3 = plt.subplots()
figc, axc = plt.subplots()
fig4, ax4 = plt.subplots()
figd, axd = plt.subplots()
fig5, ax5 = plt.subplots()
fig6, ax6 = plt.subplots()
fig7, ax7 = plt.subplots()

#représentation graphique
ax1.set_title("Variations de DELTAT et deltat en fonction des valeurs de M pour P=0.6 fixé")
ax1.set_xlabel("Valeurs de M")
ax1.grid(True)
ax1.set_ylabel("Intervalle de temps en années")
ax1.plot(RXmp06, VARDELTATP06, label="Variation de DeltaT")
ax1.plot(RXmp06, VARdeltatP06, label="Variation de deltat")
ax1.legend()

#affichage des figures 
fig1.show()

#représentation graphique
axa.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de M pour P=0.6 fixé")
axa.set_xlabel("Valeurs de M")
axa.grid(True)
axa.set_ylabel("Rayon minimal (en mm)")
axa.plot(RXmp06, VARRAYMINP06)

#affichage figures 
figa.show()

#représentation graphique 
ax2.set_title("Variations de DELTAT et deltat en fonction des valeurs de M pour P=0.7 fixé")
ax2.set_xlabel("Valeurs de M")
ax2.grid(True)
ax2.set_ylabel("Intervalle de temps en années")
ax2.plot(RXmp06, VARDELTATP07, label="Variation de DeltaT")
ax2.plot(RXmp06, VARdeltatP07, label="Variation de deltat")
ax2.legend()

#affichage des figures 
fig2.show()

#représentation graphique 
axb.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de M pour P=0.7 fixé")
axb.set_xlabel("Valeurs de M")
axb.grid(True)
axb.set_ylabel("Rayon minimal (en mm)")
axb.plot(RXmp06, VARRAYMINP07)

#affichage des figures 
figb.show()

#représentation graphique 
ax3.set_title("Variations de DELTAT et deltat en fonction des valeurs de M pour P=0.8 fixé")
ax3.set_xlabel("Valeurs de M")
ax3.grid(True)
ax3.set_ylabel("Intervalle de temps en années")
ax3.plot(RXmp06, VARDELTATP08, label="Variation de DeltaT")
ax3.plot(RXmp06, VARdeltatP08, label="Variation de deltat")
ax3.legend()

#affichage des figures 
fig3.show()

#représentation graphique 
axc.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de M pour P=0.8 fixé")
axc.set_xlabel("Valeurs de M")
axc.grid(True)
axc.set_ylabel("Rayon minimal (en mm)")
axc.plot(RXmp06, VARRAYMINP08)

#affichage des figures 
figc.show()


#représentation graphique 
ax4.set_title("Variations de DELTAT et deltat en fonction des valeurs de M pour P=0.9 fixé")
ax4.set_xlabel("Valeurs de M")
ax4.grid(True)
ax4.set_ylabel("Intervalle de temps en années")
ax4.plot(RXmp09, VARDELTATP09seul, label="Variation de DeltaT")
ax4.plot(RXmp09, VARdeltatP09seul, label="Variation de deltat")
ax4.legend()

#affichage des figures 
fig4.show()

#représentation graphique 
axd.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de M pour P=0.9 fixé")
axd.set_xlabel("Valeurs de M")
axd.grid(True)
axd.set_ylabel("Rayon min(en mm)")
axd.plot(RXmp09, VARRAYMINP09seul)
figd.show()
figd.savefig("NRVARRAYONPFIXE09.pdf", bbox_iches='tight')

#affichage des figures 
ax5.set_title("Variations de DELTAT en fonction des valeurs de M pour plusieurs valeurs de p fixées")
ax5.set_xlabel("Valeurs de M")
ax5.set_ylabel("Intervalle de temps en années")
ax5.grid(True)
ax5.plot(RXmp06, VARDELTATP06, label="Variation de DeltaT pour P=0.6fixé")
ax5.plot(RXmp06, VARDELTATP07, label="Variation de DeltaT pour P=0.7 fixé")
ax5.plot(RXmp06, VARDELTATP08, label="Variation de DeltaT pour P=0.8 fixé")
ax5.plot(RXmp06, VARDELTATP09, label="Variation de DeltaT pour P=0.9 fixé")
ax5.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')
fig5.show()

#représentation graphique 
ax6.set_title("Variations de deltat en fonction des valeurs de M pour plusieurs valeurs de p fixées")
ax6.set_xlabel("Valeurs de M")
ax6.set_ylabel("Intervalle de temps en années")
ax6.grid(True)
ax6.plot(RXmp06, VARdeltatP06, label="Variation de deltat pour P=0.6 fixé")
ax6.plot(RXmp06, VARdeltatP07, label="Variation de deltat pour P=0.7 fixé")
ax6.plot(RXmp06, VARdeltatP08, label="Variation de deltat pour P=0.8 fixé")
ax6.plot(RXmp06, VARdeltatP09, label="Variation de deltat pour P=0.9 fixé")
ax6.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichage des figures 
fig6.show()

#représentation  graphique 
ax7.set_title("Variations du rayon en fonction des valeurs de M pour plusieurs valeurs de P fixées")
ax7.set_xlabel("Valeurs de M")
ax7.set_ylabel("Rayon tumoral (en mm)")
ax7.grid(True)
ax7.plot(RXmp06, VARRAYMINP06, label="Variation de rayon pour P=0.6 fixé")
ax7.plot(RXmp06, VARRAYMINP07, label="Variation de rayon pour P=0.7 fixé")
ax7.plot(RXmp06, VARRAYMINP08, label="Variation de rayon pour P=0.8 fixé")
ax7.plot(RXmp06, VARRAYMINP09, label="Variation de rayon pour P=0.9 fixé")
ax7.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichage des figures 
fig7.show()
\end{lstlisting}
\\
\newpage
\subsection{Étude du paramètre $p$:}
\\
\subsubsection{Variations du rayon tumoral pour plusieurs valeurs de $p$}
\\

\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#paramètres du temps 
Tempstot = 20 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance en effet 
#de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

#localisations sur les figures 
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height


#paramètres de l'espace et autres 
#calculer L= taille physique boîte(mm)/
L= 70 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la représentation de l'espace
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion
k=1 #coeff de proliferation 
P03=0.65 #proportion de cellules atteintes par la RT
P06=0.85 #proportion de cellules atteintes par la RT
P15=0.95 #proportion de cellules atteintes par la RT
M=2.5 #taux de mort 
nbt0 = 950 #appli de la RT
alpha = (D*Delta_t)/dx2 #défini par rapport à l'intervalle de temps, dx et D 
print(alpha)
seuil = np.full(N1, 0.07)
seuill = 0.07 #seuil de détection 
vitfront = 2*np.sqrt(D*k)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k))
vit_front=np.full(nb_iterations, 2*np.sqrt(D*k))
vit_frontdix=np.full(nb_iterations, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k)))


#matrice M1D pour les prochains calculs
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#conditions initiales données par la marche 
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#calcul d'une seule itération pour la diffusion 
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer la diffusion au rang n+1
def solutions(MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f+1):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations)   

#création des vecteurs vides pour la suite

TpreuveTempRT03=[]
TpreuveTempn03=[]
sommem03 = []

TpreuveTempRT06=[]
TpreuveTempn06=[]
sommem06 = []

TpreuveTempRT15=[]
TpreuveTempn15=[]
sommem15 = []

zero = np.zeros(N1)
#fonction calculant la diffusion proliferation avant la RT
def DiffProlif(TpreuveTempn, TpreuveTempRT, U01, nbt0, sommem): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    sommem.extend([oo])
    TpreuveTempn.extend([oo])
    TpreuveTempRT.extend([zero])
    for i in range(1, nbt0):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        sommem.extend([UP])
        TpreuveTempn.extend([UP])
        TpreuveTempRT.extend([zero])
    return TpreuveTempn, TpreuveTempRT, sommem
TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlif(TpreuveTempn03, TpreuveTempRT03, U01, nbt0, sommem03) #remplissement du vecteur diffprolif
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlif(TpreuveTempn06, TpreuveTempRT06, U01, nbt0, sommem06) #remplissement du vecteur diffprolif
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlif(TpreuveTempn15, TpreuveTempRT15, U01, nbt0, sommem15) #remplissement du vecteur diffprolif


#fonction calculant les valeurs de la diffusion puis de la prolifération après RT
def DiffProlifRT(TpreuveTempn, M, TpreuveTempRT, nbt0, sommem, p): 
    oo=np.zeros(N1)
    op=np.zeros(N1)
    for i in range(0, N1-1):
        oo[i]= p*TpreuveTempn[nbt0-1][i]
        op[i]= (1-p)*TpreuveTempn[nbt0-1][i]

    Tpreuver = resol(A,B,C, oo)
    Tpreuven = resol(A,B,C, op)
    oo = np.zeros(N1)
    op = np.zeros(N1)
    s = np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=Tpreuver[m] + (M*Delta_t*Tpreuver[m]*(1 - (Tpreuver[m])))
        op[m]= (Tpreuven[m]) + k*Delta_t*Tpreuven[m]*(1 -Tpreuven[m] - Tpreuver[m] )
        s[m]= op[m] + oo[m]
        
    sommem.extend([s])    
    TpreuveTempRT.extend([oo])
    TpreuveTempn.extend([op])
    for i in range(nbt0+1, nb_iterations):
        
        TPRT= np.zeros(N1)
        UPRT=np.zeros(N1)
        TPRT = resol(A,B,C, TpreuveTempRT[i-1])
        s = np.zeros(N1)
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UPRT[j] = TPRT[j] - (M*Delta_t*TPRT[j]*(1-TPRT[j]))
            cd= TPRT[j]
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- TP[j] - cd)
            s[j] = UP[j] +UPRT[j]
            
        sommem.extend([s])
        TpreuveTempRT.extend([UPRT])
        TpreuveTempn.extend([UP])
    return TpreuveTempn, TpreuveTempRT, sommem

TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlifRT(TpreuveTempn03, M, TpreuveTempRT03, nbt0, sommem03, P03) 
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlifRT(TpreuveTempn06, M, TpreuveTempRT06, nbt0, sommem06, P06) 
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlifRT(TpreuveTempn15, M, TpreuveTempRT15, nbt0, sommem15, P15) 


#Calcul du rayon tumoral 
RXn03= []
RYn03 = []

RXn06= []
RYn06 = []

RXn15= []
RYn15 = []

def rayonn(TpreuveTempn, seuill, RXn, RYn):
    for i in range(0, nb_iterations):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTempn[i][j] <= seuill ) and ( TpreuveTempn[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RXn.extend([r])
        RYn.extend([i*Delta_t])
    return RXn, RYn
                
RXn03, RYn03 = rayonn(sommem03, seuill, RXn03, RYn03)  
RXn06, RYn06 = rayonn(sommem06, seuill, RXn06, RYn06)  
RXn15, RYn15 = rayonn(sommem15, seuill, RXn15, RYn15)

#On cherche a trouver le moment où le rayon est minimal suite a la session de RT (deltag) et sa valeur 
def minn(RX):
    minim=35
    indice = 0
    deltag=0
    for i in range (nbt0, nb_iterations):
        m = RX[i]
        if (m<minim):
            minim = m
            indice = i *Delta_t
            deltag= (i*Delta_t) - (nbt0*Delta_t)
    return minim, indice, deltag

minimRX03, indicemin03, deltag03 = minn(RXn03) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX03)
print("indice", indicemin03)
print("deltag", deltag03)


minimRX06, indicemin06, deltag06 = minn(RXn06) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX06)
print("indice", indicemin06)
print("deltag", deltag06)

minimRX15, indicemin15, deltag15 = minn(RXn15) #fonction retournant la valeur minimum du rayon ainsi que le moment m auquel cette valeur min est atteinte
print("minimRX", minimRX15)
print("indice", indicemin15)
print("deltag", deltag15)

#étude du DeltaG
def momentegal(RX):
    bingo=RX[nbt0]
    DELTAG=0
    for i in range(nbt0, nb_iterations):
        if ( ( RX[i-1] <= bingo ) and ( RX[i] >= bingo ) ):
            DELTAG = (i*Delta_t) - (nbt0*Delta_t) 
    return DELTAG

DELTAG03 = momentegal(RXn03)
print("DELTAG03 = ",DELTAG03)

DELTAG06 = momentegal(RXn06)
print("DELTAG06 = ",DELTAG06)

DELTAG15 = momentegal(RXn15)
print("DELTAG15 = ",DELTAG15)

#création des figures vides 
fig2, ax2 = plt.subplots(ncols=1)
fig2.subplots_adjust(wspace=0.75)  

fig4, ax4 = plt.subplots(ncols=1)
fig4.subplots_adjust(wspace=0.75)

#représentation graphique 
ax2.set_title(" DIFFUSION PROLIFERATION CELLULES ")
ax2.grid(True)
ax2.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 P=0.9 M=1.1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax2.transAxes)
ax2.set_xlabel("Longueur de la boîte (en mm)")
ax2.set_ylabel("Densité cellulaire")
ax2.plot(X, sommem03[0], label="sol_approch c t=0dt", color='black' )
ax2.plot(X, sommem03[20], label="sol_approch c t=20dt", color='black')
ax2.plot(X, sommem03[50], label="sol_approch c t=50dt", color='black')
ax2.plot(X, sommem03[250], label="sol_approch c t=250dt", color='black')
ax2.plot(X, sommem03[500], label="sol_approch ct=500dt moment irradiation RT", color='red')
ax2.plot(X, sommem03[550], label="sol_approch ct=550dt", color='yellow')
ax2.plot(X, sommem03[625], label="sol_approch ct=625dt", color='orange')
ax2.plot(X, sommem03[750], label="sol_approch c  t=750dt", color='magenta')
ax2.plot(X, sommem03[850], label="sol_approch c  t=850dt", color='purple')
ax2.plot(X, sommem03[950], label="sol_approch c  t=950dt", color='blue')
ax2.plot(X, sommem03[1150], label="sol_approch c  t=1150dt", color='green')
ax2.plot(X, sommem03[1500], label="sol_approch c t=1500dt", color='gray')
ax2.plot(X, sommem03[nb_iterations-1], label="sol_approch c t=Tempstot", color='gray')
ax2.legend(bbox_to_anchor=(-0.9, -0.9, -0.9, -0.9), loc='lower left')


ax4.set_title("VARIATION DU RAYON TUMORAL ")
ax4.grid(True)
ax4.set_xlim([0, 18])
ax4.set_ylim([0, 35])
ax4.set_xlabel("Temps (en années)")
ax4.set_ylabel("Rayon de la tumeur (en mm)")
ax4.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1 M=2.5 ans^-1 fixés",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax4.transAxes)
ax4.annotate('Session de radiothérapie', xy=(9.5,15.1), xytext=(3.5,20.2), arrowprops={'facecolor':'black', 'shrink':0.05} )
ax4.plot(RYn03, RXn03, label="P=0.65")
ax4.plot(RYn06, RXn06, label="P=0.85")
ax4.plot(RYn15, RXn15, label="P=0.95")
ax4.legend(bbox_to_anchor=(-0.5, -0.5, -0.5, -0.5), loc='lower left')

#affichage des figures 

fig2.show()
fig4.show()
\end{lstlisting}
\\

\newpage
\subsubsection{Étude de la pente associée à la courbe du rayon tumoral}
\\
\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#paramètres du temps 
Tempstot = 20 #en années 
Delta_t = 0.01  ##en années, il s'agit du pas, on avance 
#en effet de 10**-2 années par itération
nb_iterations  = int(Tempstot/Delta_t) #taille vecteur temps
print("nbiterations = ", int(nb_iterations))

#paramètres de l'espace et autres 
#calculer L= taille physique boite (mm)/
L= 70 #en mm
dx= 0.01 #en mm
dx2 = (dx)**2
N1 = int(L/dx) #taille de la représentation de l'espace
X = np.arange(0 , L, dx)
D = 1 #coeff de diffusion
k=1 #coeff de prolifération 
P03=0.65 #proportion des cellules atteintes par la RT 
P06=0.85 #proportion des cellules atteintes par la RT 
P15=0.95 #proportion des cellules atteintes par la RT 
M=2.5 #taux de mort 
 #proportion des cellules atteintes par la RT
nbt0 = 950 #Appli de la RT
alpha = (D*Delta_t)/dx2 #defini par rapport à l'intervalle de temps, dx et D
print(alpha)
seuil = np.full(N1, 0.07)
seuill = 0.07 #seuil de détection 
vitfront = 2*np.sqrt(D*k)
vitfrontdix = 2*np.sqrt(D*k) + (0.1*2*np.sqrt(D*k))
vit_front=np.full(nb_iterations, 2*np.sqrt(D*k))
vit_frontdix=np.full(nb_iterations, (2*np.sqrt(D*k) +0.1*2*np.sqrt(D*k)))


#matrice M1D pour les prochains calculs
def MatriceMD1(N1, alpha): 
    MD1 = np.zeros((N1,N1))
    for i in range (0, N1):
        for j in range (0, N1): 
            if (i == j) :
                MD1[i,j]= 1. + 2*alpha 
            elif (i+1 == j or i-1 == j) :
                MD1[i,j]= -alpha
    MD1[0,1]= MD1[0,1]-alpha
    return MD1           

MD1 = MatriceMD1(N1, alpha)
print("MD1= ", MD1)

#on stocke les diagonales dans les nouveaux vecteurs vides 
A=np.full(N1, 1+2*alpha)
C=np.full(N1, -alpha)
C[0]=0
B=np.full(N1, -alpha)
B[0]=-2*alpha
B[N1-1]=0

#création du vecteur contenant les conditions initiales de la marche
U01=np.zeros(N1)
U01[0]=1
U01[1]=1

#calcul d'une seule itération pour la diffusion 
def resol(B, C, A, R ): 
    gam = np.zeros(N1) 
    U=np.zeros(N1)
    if (B[0]==0):
        print("ERROR!")
    bet=B[0]
    U[0]= (R[0]/(bet))
    for j in range(1, N1-1):
        gam[j] = C[j-1]/bet 
        bet=B[j]-A[j]*gam[j] 
        if (bet==0):
            print("ERROR!")
        U[j]=(R[j]-(A[j]*U[j-1]))/(bet)
    k=N1-2 
    while k>=0:
        U[k] -= gam[k+1]*U[k+1]
        k = k-1 
    gam=np.zeros(N1)
    return U

#boucle pour calculer la diffusion au rang n+1
def solutions(MD1, N1, f):
    if(f==0):
        return U01
    U = np.zeros(N1)
    UI = np.zeros(N1)
    UI = resol(A, B, C, U01) 
    if (f==1):
        return UI
    for i in range(2,nb_iterations+3):
         U = resol(A, B, C, UI) 
         UI = U
         if i==(f+1):
             return U
 
solutionsadt= solutions(MD1, N1, nb_iterations)   

#création des vecteurs vides pour la suite 
TpreuveTempRT03=[]
TpreuveTempn03=[]
sommem03 = []

TpreuveTempRT06=[]
TpreuveTempn06=[]
sommem06 = []

TpreuveTempRT15=[]
TpreuveTempn15=[]
sommem15 = []

#calcul de la diffusion puis la prolifération avant RT
zero = np.zeros(N1)
def DiffProlif(TpreuveTempn, TpreuveTempRT, U01, nbt0, sommem): 
    oo=np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=U01[m] + k*Delta_t*U01[m]*(1-U01[m])
    sommem.extend([oo])
    TpreuveTempn.extend([oo])
    TpreuveTempRT.extend([zero])
    for i in range(1, nbt0):
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- (TP[j]))
        sommem.extend([UP])
        TpreuveTempn.extend([UP])
        TpreuveTempRT.extend([zero])
    return TpreuveTempn, TpreuveTempRT, sommem
TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlif(TpreuveTempn03, TpreuveTempRT03, U01, nbt0, sommem03) #remplissement du vecteur diffprolif
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlif(TpreuveTempn06, TpreuveTempRT06, U01, nbt0, sommem06) #remplissement du vecteur diffprolif
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlif(TpreuveTempn15, TpreuveTempRT15, U01, nbt0, sommem15) #remplissement du vecteur diffprolif


#fonction calculant les valeurs de la diffusion puis de la prolifération après RT
def DiffProlifRT(TpreuveTempn, M, TpreuveTempRT, nbt0, sommem, p): 
    oo=np.zeros(N1)
    op=np.zeros(N1)
    for i in range(0, N1-1):
        oo[i]= p*TpreuveTempn[nbt0-1][i]
        op[i]= (1-p)*TpreuveTempn[nbt0-1][i]

    Tpreuver = resol(A,B,C, oo)
    Tpreuven = resol(A,B,C, op)
    oo = np.zeros(N1)
    op = np.zeros(N1)
    s = np.zeros(N1)
    for m in range(0, N1-1):
        oo[m]=Tpreuver[m] + (M*Delta_t*Tpreuver[m]*(1 - (Tpreuver[m])))
        op[m]= (Tpreuven[m]) + k*Delta_t*Tpreuven[m]*(1 -Tpreuven[m] - Tpreuver[m] )
        s[m]= op[m] + oo[m]
        
    sommem.extend([s])    
    TpreuveTempRT.extend([oo])
    TpreuveTempn.extend([op])
    for i in range(nbt0+1, nb_iterations):
        
        TPRT= np.zeros(N1)
        UPRT=np.zeros(N1)
        TPRT = resol(A,B,C, TpreuveTempRT[i-1])
        s = np.zeros(N1)
        TP= np.zeros(N1)
        UP=np.zeros(N1)
        TP = resol(A,B,C, TpreuveTempn[i-1])
        for j in range(0, N1-1):
            UPRT[j] = TPRT[j] - (M*Delta_t*TPRT[j]*(1-TPRT[j]))
            cd= TPRT[j]
            UP[j] = TP[j] + k*Delta_t*TP[j]*(1- TP[j] - cd)
            s[j] = UP[j] +UPRT[j]
            
        sommem.extend([s])
        TpreuveTempRT.extend([UPRT])
        TpreuveTempn.extend([UP])
    return TpreuveTempn, TpreuveTempRT, sommem

TpreuveTempn03, TpreuveTempRT03, sommem03 = DiffProlifRT(TpreuveTempn03, M, TpreuveTempRT03, nbt0, sommem03, P03) 
TpreuveTempn06, TpreuveTempRT06, sommem06 = DiffProlifRT(TpreuveTempn06, M, TpreuveTempRT06, nbt0, sommem06, P06) 
TpreuveTempn15, TpreuveTempRT15, sommem15 = DiffProlifRT(TpreuveTempn15, M, TpreuveTempRT15, nbt0, sommem15, P15) 


#Calcul du rayon 
RXn03= []
RYn03 = []

RXn06= []
RYn06 = []

RXn15= []
RYn15 = []

def rayonn(TpreuveTempn, seuill, RXn, RYn):
    for i in range(0, nb_iterations):
        r=0
        for j in range(1, N1-1):
            if ( ( TpreuveTempn[i][j] <= seuill ) and ( TpreuveTempn[i][j-1] >= seuill ) ):
                r = (((j-1)+j)/2)*dx
        RXn.extend([r])
        RYn.extend([i*Delta_t])
    return RXn, RYn
                
RXn03, RYn03 = rayonn(sommem03, seuill, RXn03, RYn03)  
RXn06, RYn06 = rayonn(sommem06, seuill, RXn06, RYn06)  
RXn15, RYn15 = rayonn(sommem15, seuill, RXn15, RYn15)

#calcul de la pente associée a la courbe du rayon tumoral 
def pente(RY, RX):
    pente = np.zeros(nb_iterations)
    for i in range(4, nb_iterations-5):
        pente[i] = (RX[i+4] - RX[i-4]) / (RY[i+4] - RY[i-4])
    return pente 
pente03 = pente(RYn03, RXn03)
max_value03 = max(pente03)
maxi03 = (np.where(pente03 == max_value03)[0][0])*Delta_t
print("maxi03", maxi03)

pente06 = pente(RYn06, RXn06)
pente06 = pente(RYn06, RXn06)
max_value06 = max(pente06)
maxi06 = (np.where(pente06 == max_value06)[0][0])*Delta_t
print("maxi06", maxi06)

pente15 = pente(RYn15, RXn15)
pente15 = pente(RYn15, RXn15)
max_value15 = max(pente15)
maxi15 = (np.where(pente15 == max_value15)[0][0])*Delta_t
print("maxi15", maxi15)

#création des figures vides 
fig4, ax4 = plt.subplots(ncols=1)
fig4.subplots_adjust(wspace=0.75)

#localisation sur les figures 
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique 
ax4.set_title("VARIATION DE LA PENTE")
ax4.grid(True)
ax4.set_xlim([0, 19])
ax4.set_xlabel("Temps (en années)")
ax4.set_ylabel("Coefficient de la pente")
ax4.text(.8, -0.4, "D=1mm^2/an K=1 ans^-1",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax4.transAxes)
ax4.plot(RYn03, pente03, label="Pour P=0.65 pour M=2.5")
ax4.plot(RYn06, pente06, label="Pour P=0.85 pour M=2.5")
ax4.plot(RYn15, pente15, label="Pour P=0.95 pour M=2.5")
ax4.legend(bbox_to_anchor=(-0.5, -0.5, -0.5, -0.5), loc='lower left')

#affichage des figures 
fig4.show()
\end{lstlisting}
\\
\newpage
\subsubsection{Variations des intervalles $\Delta G$, $\Delta g$ et des valeurs du rayon tumoral}
\\

\begin{lstlisting}[style=stylepython]
import numpy as np
import matplotlib.pyplot as plt

#définition des valeurs calculées auparavant 
RXp = [0.6, 0.7, 0.8, 0.9]

#pour M=1.5: définition des valeurs calculées auparavant 
VARDELTAGM15 = [0.48, 0.88, 1.38, 2.14]
VARdeltagM15= [0.17, 0.42, 0.65, 1.11]
VARrayM15= [6.105, 5.935, 5.585, 4.665 ]

#pour M=2.5 : définition des valeurs calculées auparavant 
VARDELTAGM25 = [0.74, 1.07, 1.49, 2.17]
VARdeltagM25= [0.31, 0.5, 0.65, 0.97]
VARrayM25= [5.885, 5.565, 4.995, 3.525 ]

#pour M=4.0 : définition des valeurs calculées auparavant 
VARDELTAGM4 = [0.83, 1.12, 1.51, 2.16]
VARdeltagM4= [0.34, 0.45, 0.59, 0.82]
VARrayM4=[5.595, 5.155, 4.365, 2.085]

#création des figures vides 
fig1, ax1 = plt.subplots()
figa, axa = plt.subplots()
fig2, ax2 = plt.subplots()
figb, axb = plt.subplots()
fig3, ax3 = plt.subplots()
figc, axc = plt.subplots()
fig4, ax4 = plt.subplots()
fig4a, ax4a = plt.subplots()
fig5, ax5 = plt.subplots()

#localisation sur les figures 
left, width = .9, .2
bottom, height = .1, 1.5
right = left + width
top = bottom + height

#représentation graphique 
ax1.set_title("Variations de DELTAG et deltag en fonction des valeurs de p pour M=1.5 fixé")
ax1.set_xlabel("Valeurs de P")
ax1.grid(True)
ax1.set_ylabel("Intervalle de temps en années")
ax1.plot(RXp, VARDELTAGM15, label="Variation de DeltaT")
ax1.plot(RXp, VARdeltagM15, label="Variation de deltat")
ax1.legend()

#affichage figures 
fig1.show()

#représentation graphique 
axa.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de P pour M=1.5 fixé")
axa.set_xlabel("Valeurs de P")
axa.grid(True)
axa.set_ylabel("Rayon minimal (en mm)")
axa.plot(RXp, VARrayM15)

#affichage figures 
figa.show()

#représentation graphique 
ax2.set_title("Variations de DELTAG et deltag en fonction des valeurs de p pour M=2.5 fixé")
ax2.set_xlabel("Valeurs de P")
ax2.grid(True)
ax2.set_ylabel("Intervalle de temps en années")
ax2.plot(RXp, VARDELTAGM25, label="Variation de DeltaT")
ax2.plot(RXp, VARdeltagM25, label="Variation de deltat")
ax2.legend()

#affichage figures 
fig2.show()

#représentation graphique 
axb.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de p pour M=2.5 fixé")
axb.set_xlabel("Valeurs de P")
axb.grid(True)
axb.set_ylabel("Rayon minimal (en mm)")
axb.plot(RXp, VARrayM25)

#affichage des figures 
figb.show()

#représentation graphique 
ax3.set_title("Variations de DELTAG et deltag en fonction des valeurs de p pour M=4 fixé")
ax3.set_xlabel("Valeurs de P")
ax3.set_ylabel("Intervalle de temps en années")
ax3.grid(True)
ax3.plot(RXp, VARDELTAGM4, label="Variation du DeltaT pour M=4.0 fixé")
ax3.plot(RXp, VARdeltagM4, label="Variation du deltat pour M=4.0 fixé")
ax3.legend()

#affichage des figures
fig3.show()

#représentation graphique
axc.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de p pour M=4.0 fixées")
axc.set_xlabel("Valeurs de P")
axc.grid(True)
axc.set_ylabel("Rayon minimal (en mm)")
axc.plot(RXp, VARrayM4)

#affichage figures 
figc.show()

#représentation graphique 
ax4.set_title("Variations de DELTAG fonction des valeurs de p pour plusieurs valeurs de M fixées")
ax4.set_xlabel("Valeurs de P")
ax4.set_ylabel("Intervalle de temps en années")
ax4.grid(True)
ax4.plot(RXp, VARDELTAGM15, label="Variation du DeltaT pour M=1.5 fixé")
ax4.plot(RXp, VARDELTAGM25, label="Variation du DeltaT pour M=2.5 fixé")
ax4.plot(RXp, VARDELTAGM4, label="Variation du DeltaT pour M=4.0 fixé")

#affichage figures
fig4.show()

#représentation graphique 
ax4a.set_title("Variations de deltag en fonction des valeurs de p pour plusieurs valeurs de M fixées")
ax4a.set_xlabel("Valeurs de p")
ax4a.set_ylabel("Intervalle de temps en années")
ax4a.grid(True)
ax4a.plot(RXp, VARdeltagM15, label="Variation du deltat pour M=1.5 fixé")
ax4a.plot(RXp, VARdeltagM25, label="Variation du deltat pour M=2.5 fixé")
ax4a.plot(RXp, VARdeltagM4, label="Variation du deltat pour M=4.0 fixé")
ax4a.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichages figures
fig4a.show()


#représentation graphique 
ax5.set_title("Variations de la valeur du rayon minimal en fonction des valeurs de P pour plusieurs valeurs de M fixées" )
ax5.set_xlabel("Valeurs de P")
ax5.grid(True)
ax5.set_ylabel("Rayon minimal (en mm)")
ax5.plot(RXp, VARrayM15, label="Variation du rayon pour M=1.5 fixé")
ax5.plot(RXp, VARrayM25, label="Variation du rayon pour M=2.5 fixé")
ax5.plot(RXp, VARrayM4, label="Variation du rayon pour M=4 fixé")
ax5.legend(bbox_to_anchor=(-0.6, -0.6, -0.6, -0.6), loc='lower left')

#affichage des figures 
fig5.show()
\end{lstlisting}

\end{document}